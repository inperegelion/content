---
title: for...in
slug: Web/JavaScript/Reference/Statements/for...in
tags:
  - JavaScript
  - Language feature
  - Statement
browser-compat: javascript.statements.for_in
---
{{jsSidebar("Statements")}}

**Інструкція `for...in`** ("для кожного ... у") перебирає всі [перелічувані властивості](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties) об'єкта, ключами яких є рядки (тобто ігноруючи ті, ключами яких є [Символи](/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol)), в тому числі успадковані перелічувані властивості.

{{EmbedInteractiveExample("pages/js/statement-forin.html")}}

## Синтаксис

```js
for (variable in object) {
  statement
}
```

- `variable`
  - : Змінна, якій під час кожної ітерації присвоюється нове ім'я властивості.
- `object`
  - : Об'єкт, чиї перелічувані властивості з несимвольними ключами зараз перебираються.

## Description

Цикл `for...in` перебирає лише ті перелічувані властивості, чиїм ключем не є символ. Об'єкти, які створюються за допомогою таких вбудованих конструкторів, як `Array` і `Object`, мають неперелічувані властивості, успадковані від `Object.prototype` та `String.prototype`, як от метод {{jsxref("String.indexOf", "indexOf()")}} об'єкту {{jsxref("String")}} чи метод {{jsxref("Object.toString", "toString()")}} об'єкта {{jsxref("Object")}}. Цикл опрацює всі власні перелічувані властивості об'єкта, а також ті, що успадковуються об'єктом від його прототипного ланцюжка (властивості ближчих прототипів мають перевагу над властивостями тих прототипів, які знаходяться далі від об'єкта у ланцюжку прототипів).

### Видалені, додані чи змінені властивості

Цикл `for...in` перебирає властивості об'єкта у довільному порядку (більше деталей про те, чому не можна залежати від позірної впорядкованості цього перебирання, принаймні в кросбраузерному контексті, — в описі оператора {{jsxref("Operators/delete", "delete")}}).

Якщо під час однієї з ітерацій властивість змінюється, а потім опрацьовується в одній з наступних ітерацій, в циклі буде використано те значення, яке вона має на момент її опрацювання другого разу. Властивість, яку було видалено перед її обробкою, пізніше оброблено не буде. Властивості, які додаються до об'єкта під час перебирання його властивостей, можуть бути як оброблені пізніше, так і пропущені в циклі.

Загалом краще не додавати, не змінювати й не видаляти властивості з об'єкта під час ітерування, поза властивістю, які безпосередньо обробляється ітерацією. Немає ніяких гарантій того, що додана властивість буде опрацьована циклом, змінена властивість буде оброблена до або після модифікації, чи що видалена властивість буде опрацьована до моменту видалення.

### Ітерування масиву і цикл for...in

> **Примітка:** не слід вживати `for...in` для перебирання {{jsxref("Array", "масивів")}},
> де важливий порядок значення індексу.

Індекси масиву — це лише перелічувані властивості, які у всьому ідентичні властивостям звичайних об'єктів, окрім того, що їхні імена — це цілі числа. Немає гарантії, що цикл `for...in` повертатиме індекси в певному порядку. Інструкція циклу `for...in` поверне всі перелічувані властивості, включно з успадкованими, а також такими, чиї імена не є цілими числами.

Оскільки порядок перебирання залежить від реалізації, перебирання елементів масиву не гарантує постійного порядку обробки елементів. Тому краще використовувати цикл {{jsxref("Statements/for", "for")}} з числовим індексом (або {{jsxref("Array.prototype.forEach()")}} чи цикл {{jsxref("Statements/for...of", "for...of")}}) під час перебирання масивів, якщо порядок обробки елементів має значення.

### Перебирання лише власних властивостей об'єкту

В разі, якщо необхідно розглянути лише ті властивості, які приєднані до самого об'єкта, без урахування його прототипів, можна застосувати один із наступних підходів:

- {{jsxref("Object.getOwnPropertyNames", "Object.getOwnPropertyNames(myObject)")}}
- {{jsxref("Object.hasOwn", "Object.hasOwn(myObject)")}}

Якщо метод `Object.hasOwn()` недоступний, можна натомість використати {{jsxref("Object.prototype.hasOwnProperty", "hasOwnProperty()")}}, хоча в такому разі краще вжити форму `Object.prototype.hasOwnProperty.call(myObject, prop)` — на випадок, якщо `myObject` перезаписав успадкований метод `hasOwnProperty()`.

## Для чого взагалі слід використовувати for...in?

Якщо зважити, що `for...in` створювався для взаємодії з властивостями об'єктів, і він не рекомендується до використання з масивами, і при цьому існують такі варіанти, як `Array.prototype.forEach()` і `for...of`, то для чого взагалі може бути корисним цикл `for...in`?

Найбільш доцільним може бути його використання для потреб зневадження, як простого способу перевірити властивості об'єкту (шляхом виведення їх у консоль, або ж інакшим чином). І хоча масиви часто є практичнішим способом зберігання даних, в ситуаціях, коли доцільніше використовувати для роботи з даними формат ключ-значення (де імена властивостей грають роль "ключа"), можуть траплятися випадки, коли потрібно перевірити чи якийсь із тих ключів зберігає певне значення.

## Приклади

### Застосування for...in

Цикл `for...in`, який наведено нижче, перевіряє всі перелічувані, несимвольні властивості об'єкта, і для кожної друкує рядок з іменем властивості та її значенням.

```js
var obj = {a: 1, b: 2, c: 3};

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Вивід:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

### Перебирання власних властивостей об'єкта

Наступна функція демонструє використання методу {{jsxref("Object.prototype.hasOwnProperty", "hasOwnProperty()")}}: успадковані властивості не виводяться.

```js
var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (const prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}

// Вивід:
// "obj.color = red"
```

## Специфікації

{{Specifications}}

## Сумісність із браузерами

{{Compat}}

### Сумісність: вираз ініціалізації в суворому режимі

У Firefox до версії 40, було можливо використовувати вираз ініціалізації (`i=0`) у циклі `for...in`:

```js example-bad
var obj = {a: 1, b: 2, c: 3};
for (var i = 0 in obj) {
  console.log(obj[i]);
}
// 1
// 2
// 3
```

Ця нестандартна поведінка ігнорується починаючи з версії 40, і покаже помилку {{jsxref("SyntaxError")}} ("[заголовок оголошення циклу for-in не може містити вирази ініціалізації](/uk/docs/Web/JavaScript/Reference/Errors/Invalid_for-in_initializer)") в [суворому режимі](/uk/docs/Web/JavaScript/Reference/Strict_mode) (вади [748550](https://bugzilla.mozilla.org/show_bug.cgi?id=748550) і [1164741](https://bugzilla.mozilla.org/show_bug.cgi?id=1164741)).

Інші рушії, як от v8 (Chrome), Chakra (IE/Edge) і JSC (WebKit/Safari) — також у процесі визначення, чи варто видаляти цю нестандартну поведінку.

## Дивіться також

- {{jsxref("Statements/for...of", "for...of")}} – схожа інструкція, яка перебирає _значення_ властивостей
- {{jsxref("Statements/for", "for")}}
- [Функції ітераторів і генераторів](/uk/docs/Web/JavaScript/Guide/Iterators_and_Generators) (придатні для використання з синтаксисом `for...of`)
- [Перелічуваність і належність властивостей](/uk/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)
- {{jsxref("Object.getOwnPropertyNames()")}}
- {{jsxref("Object.prototype.hasOwnProperty()")}}
- {{jsxref("Array.prototype.forEach()")}}
